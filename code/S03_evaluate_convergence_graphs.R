# This script synthesizes the results from the individual convergence evaluations.
# It reads the raw PSRF and ESS data (CSVs) generated by the S03 script
# for all runs associated with a single Model_ID. It then produces summary
# PDF files with violin plots to visually compare convergence quality across
# the different MCMC sampling schemes.

# --- 1. Load Libraries and Configuration ---
library(tidyverse)
library(vioplot)
library(colorspace)

source("code/config_model.R")

# --- 2. Setup Directories and Initialize Data Lists ---
model_id <- run_config$model_id
output_dir <- file.path("models")
dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)

message(paste0("--- Starting comparison for Model ID: ", model_id, " ---"))

# Initialize lists to store aggregated data from all runs
psrf.beta.all <- list(); ess.beta.all <- list()
psrf.gamma.all <- list(); ess.gamma.all <- list()
psrf.rho.all <- list(); ess.rho.all <- list()
psrf.V.all <- list(); ess.V.all <- list()
psrf.omega.all <- list(); ess.omega.all <- list()
psrf.alpha.all <- list(); ess.alpha.all <- list()

# --- 3. Data Aggregation Loop ---
# Loop through the grid to find and read the individual CSV reports.
for (i in 1:nrow(run_config$mcmc)) {
  run_name <- generate_run_name(run_config)[i]
  evaluation_dir <- file.path("models", run_name, "convergence")
  
  if (!dir.exists(evaluation_dir)) {
    message(paste("Evaluation directory for", run_name, "not found. Skipping."))
    next
  }
  
  message(paste("Aggregating data from:", run_name))
  
  # A helper function to safely read a CSV and add it to a list
  read_and_store <- function(param_name, metric, data_list) {
    file_path <- file.path(evaluation_dir, paste0(metric, "_", param_name, ".csv"))
    if (file.exists(file_path)) {
      # PSRF data from coda::gelman.diag is a 2-column matrix (Point est., Upper C.I.)
      # We are interested in the point estimate, which is the first column.
      if (metric == "psrf") {
        data_list[[run_name]] <- read.csv(file_path)[, "Point.est."]
      } else { # ESS is a single vector
        data_list[[run_name]] <- read.csv(file_path)[, "ess"]
      }
    }
    return(data_list)
  }
  
  psrf.beta.all <- read_and_store("beta", "psrf", psrf.beta.all)
  ess.beta.all  <- read_and_store("beta", "ess", ess.beta.all)
  
  psrf.gamma.all <- read_and_store("gamma", "psrf", psrf.gamma.all)
  ess.gamma.all  <- read_and_store("gamma", "ess", ess.gamma.all)
  
  psrf.rho.all <- read_and_store("rho", "psrf", psrf.rho.all)
  ess.rho.all  <- read_and_store("rho", "ess", ess.rho.all)
  
  psrf.V.all <- read_and_store("v", "psrf", psrf.V.all)
  ess.V.all  <- read_and_store("v", "ess", ess.V.all)
  
  # For parameters with random levels (omega, alpha), we need to find all their files
  omega_files_psrf <- list.files(evaluation_dir, pattern = "psrf_omega_.*\\.csv", full.names = TRUE)
  if(length(omega_files_psrf) > 0) {
    # Combine all omega values for a run into a single vector
    psrf.omega.all[[run_name]] <- do.call(c, lapply(omega_files_psrf, function(f) read.csv(f)[,"Point.est."]))
  }
  
  omega_files_ess <- list.files(evaluation_dir, pattern = "ess_omega_.*\\.csv", full.names = TRUE)
  if(length(omega_files_ess) > 0) {
    ess.omega.all[[run_name]] <- do.call(c, lapply(omega_files_ess, function(f) read.csv(f)[,"ess"]))
  }
  
  alpha_files_psrf <- list.files(evaluation_dir, pattern = "psrf_alpha_.*\\.csv", full.names = TRUE)
  if(length(alpha_files_psrf) > 0) {
    psrf.alpha.all[[run_name]] <- do.call(c, lapply(alpha_files_psrf, function(f) read.csv(f)[,"Point.est."]))
  }
  
  alpha_files_ess <- list.files(evaluation_dir, pattern = "ess_alpha_.*\\.csv", full.names = TRUE)
  if(length(alpha_files_ess) > 0) {
    ess.alpha.all[[run_name]] <- do.call(c, lapply(alpha_files_ess, function(f) read.csv(f)[,"ess"]))
  }
}

# --- 4. Plotting Section ---
# This section uses your original, excellent plotting functions.
run_names_found <- names(psrf.beta.all) # Use the runs we actually found data for
if(length(run_names_found) == 0) {
  stop("No evaluation data found. Please run the S03 script first.")
}
model_colors <- rainbow_hcl(length(run_names_found))
names(model_colors) <- run_names_found

# Your plot_vioplot_section function for PSRF
plot_vioplot_section <- function(data_list, title_suffix, y_range_full, y_range_zoom, color_map) {
  if(length(data_list) > 0) {
    max_len <- max(sapply(data_list, length))
    padded_data <- lapply(data_list, function(x) c(x, rep(NA, max_len - length(x))))
    plot_matrix <- do.call(cbind, padded_data)
    
    par(mfrow=c(2,1), mar=c(8, 4, 4, 2) + 0.1)
    vioplot(plot_matrix, col=color_map[colnames(plot_matrix)], names=NULL, 
            xaxt = "n", ylim=y_range_full, main=paste0("PSRF (", title_suffix, ")"), las=2)
    abline(h = 1.1, col = "red", lty = 2)
    legend("topright", legend = names(color_map), fill=color_map, cex=0.8)
    
    vioplot(plot_matrix, col=color_map[colnames(plot_matrix)], names=NULL, 
            xaxt = "n", ylim=y_range_zoom, main=paste0("PSRF (", title_suffix, ") (Zoomed)"), las=2)
    abline(h = 1.1, col = "red", lty = 2)
    legend("topright", legend = names(color_map), fill=color_map, cex=0.8)
  }
}

# Your plot_vioplot_section_ess function for ESS
plot_vioplot_section_ess <- function(data_list, title_suffix, y_range_full, color_map, min_ess_threshold = 400) {
  if(length(data_list) > 0) {
    max_len <- max(sapply(data_list, length))
    padded_data <- lapply(data_list, function(x) c(x, rep(NA, max_len - length(x))))
    plot_matrix <- do.call(cbind, padded_data)
    
    par(mfrow=c(1,1), mar=c(8, 4, 4, 2) + 0.1)
    vioplot(plot_matrix, col=color_map[colnames(plot_matrix)], names=NULL, 
            xaxt = "n", ylim=y_range_full, main=paste0("ESS (", title_suffix, ")"), las=2)
    abline(h = min_ess_threshold, col = "red", lty = 2)
    legend("topright", legend = names(color_map), fill=color_map, cex=0.8)
  }
}

# --- Generate PSRF Plots ---
pdf(file = file.path(output_dir, paste0(model_id, "_MCMC_PSRF.pdf")), width = 11, height = 8.5)
plot_vioplot_section(psrf.beta.all, "Beta", c(0.9, max(1.2, unlist(psrf.beta.all), na.rm = TRUE)), c(0.98, 1.05), model_colors)
plot_vioplot_section(psrf.gamma.all, "Gamma", c(0.9, max(1.2, unlist(psrf.gamma.all), na.rm = TRUE)), c(0.98, 1.05), model_colors)
plot_vioplot_section(psrf.V.all, "V", c(0.9, max(1.2, unlist(psrf.V.all), na.rm = TRUE)), c(0.98, 1.05), model_colors)
plot_vioplot_section(psrf.omega.all, "Omega", c(0.9, max(1.2, unlist(psrf.omega.all), na.rm = TRUE)), c(0.98, 1.05), model_colors)
plot_vioplot_section(psrf.alpha.all, "Alpha", c(0.9, max(1.2, unlist(psrf.alpha.all), na.rm = TRUE)), c(0.98, 1.05), model_colors)
dev.off()

# --- Generate ESS Plots ---
pdf(file = file.path(output_dir, paste0(model_id, "_MCMC_ESS.pdf")), width = 11, height = 8.5)
plot_vioplot_section_ess(ess.beta.all, "Beta", c(0, max(unlist(ess.beta.all), na.rm = TRUE)), model_colors)
plot_vioplot_section_ess(ess.gamma.all, "Gamma", c(0, max(unlist(ess.gamma.all), na.rm = TRUE)), model_colors)
plot_vioplot_section_ess(ess.V.all, "V", c(0, max(unlist(ess.V.all), na.rm = TRUE)), model_colors)
plot_vioplot_section_ess(ess.omega.all, "Omega", c(0, max(unlist(ess.omega.all), na.rm = TRUE)), model_colors)
plot_vioplot_section_ess(ess.alpha.all, "Alpha", c(0, max(unlist(ess.alpha.all), na.rm = TRUE)), model_colors)
dev.off()
